# This file is equivalent to check.sage. However, this file will be updated
# to use cython for performance improvements.

import os
import operator as op
import time
from sage.all import *

moreDebug = True
edgesLeft = True

def ncr(n, r):
    r = min(r, n-r)
    if r == 0: return 1
    numer = reduce(op.mul, xrange(n, n-r, -1))
    denom = reduce(op.mul, xrange(1, r+1))
    return numer//denom

# check takes a graph G as input and returns true if the 
# graph satisfies all properties that would make
# it a good candidate for the method used in John 
# Sinkovic's Paper to find an inertia bound that
# is not tight
def check(G):
    if moreDebug:
        t0 = time.clock()
    alpha = len(G.independent_set())
    numVertices = len(G)
    if 2*alpha+1 > numVertices:
        print "alpha too large"
        return False
    if moreDebug:
        print "alpha is {}".format(alpha)
        print "numVerties is {}".format(numVertices)
        print "number of combinations will be {}".format(ncr(numVertices,2*alpha+1))
    if not is_alpha_critical(G):
        print "alpha critical"
        return False
    path = G.hamiltonian_path()
    if not path:
        print "no hamiltionian"
        path = G.random_spanning_tree()
    #if not G.is_arc_transitive():
        #return False
    subgraphs = set()
    trianglesCheck = set()
    for combo in Combinations(numVertices,2*alpha+1):
        I = G.subgraph(combo,immutable=true)
        #st = g.canonical_label().graph6_string()
        #this next while loop will delete all pendants of g,
        #then check if the resulting g is a: a single odd cycle
        # or b: a disjoint union of odd cycles. if it is in category
        # a, then it is added to trainglesCheck list, and if it is in b,
        # it is added to subgraphs list
        h = G.subgraph(combo)
        # this changed variable is necessary because when we iterate through the
        # vertices, we are deleting some and creating new pendants that we need
        # to delete also, but if we already iterated over that vertice, then
        # we won't realize that it still needs to be deleted so we need to
        # keep iterating over the vertices until we get to a point where we don't
        # find and delete any new pendants
        changed = True
        while changed:
            changed = False
            for v in h.vertex_iterator():
                if len(h[v]) == 1:
                    changed = True
                    h.delete_vertex(h[v][0])
                    h.delete_vertex(v)
                    break
        if h.is_cycle() and h.order()%2 == 1:
            copy = h.copy(immutable=true)
            trianglesCheck.add(copy)
        components = h.connected_components_subgraphs()
        if not components:
            break
        continue_loop = False
        for com in components:
            if (not com.is_cycle()) or (not com.order()%2 == 1):
                continue_loop = True 
                # need continue_loop because I want to continue out of outer for
                # loop, but using continue now will only continue out of 
                # the inner for loop
                break
        if continue_loop:
            continue
        # if we make it to this point, every component was an odd cycle
        subgraphs.add(I)
    if moreDebug:
        print "number of subgraphs: {}".format(len(subgraphs))
        print "**************************** {}".format(time.clock() - t0)
    T = graphs.CompleteGraph(3)
    Triangles = contained(G,T,trianglesCheck)
    if moreDebug:
        print "number of triangles to use: {}".format(len(Triangles))
    if moreDebug:
        print "number of triangles: {}".format(len(Triangles))
    if not Triangles:
        print "contained"
        return False
    # finished preliminary check, now to check signs
    if debug:
        print "Check passed"
        print len(subgraphs)
    for e in G.edge_iterator(labels=false):
        temp1 = e[0]
        temp2 = e[1]
        G.delete_edge(e)
        if path.has_edge(e):
            if debug:
                print e
            G.add_edge((temp1,temp2,1))
        else:
            G.add_edge((temp1,temp2,10))
    M1 = G.weighted_adjacency_matrix()
    M2 = G.weighted_adjacency_matrix()
    if debug:
        print M1
    if not signing(G,M1,subgraphs,1,Triangles):
        return False
    if moreDebug:
        print "************* Positive Signing found a contradiction **********************"
    if not signing(G,M2,subgraphs,-1,Triangles):
        return False
    if debug:
        pathGraphic = path.plot()
        pathGraphic.save('path.png')
        os.system('open path.png')
    return True


# contained returns true if the each triangle in G is
# contained in at least one subgraph of the form SubGraph and
# false otherwise
def contained(G, Triangle, SubGraphs):
    Triangles = set()
    #calculates the total number of triangles in G
    for triangle in G.subgraph_search_iterator(Triangle,induced = true):
        for s in SubGraphs:
            if set(triangle).issubset(set(s)):
                Triangles.add(tuple(triangle))
                break
    return Triangles



# is_alpha_critical returns true if the graph G is alpha critical
def is_alpha_critical(G):
    alpha=len(G.independent_set())
    for i in G.edges():
        H=G.copy()
        H.delete_edge(i)
        if len(H.independent_set())==alpha:
            return False
    return True

#g = Graph("W~ffCIWaONGYEhEYDRAH_KT?hEIBYogboAqxBBlAGEicPKt")
#graphic = g.plot()
#graphic.save('output.png')
#os.system('open output.png')
#print check(g)

#this debug variable is to control the output to the screen. If it is set to true,
#steps of the process will be printed to the screen. If it is false, the functions will
#not output anything to the screen.
edgesLeft = True
debug = False
# signing accepts a graph G, a matrix that will hold the signs of edges, M, and
# a list of nonsingular subgraphs of G of size 2alpha+1. This function will
# attempt to determine the signing of G and find a contradiction for a tight
# inertia bound using the list of subgraphs. M will hold the signs of the edges
# throughout. M[i,j] will equal 1 if the edge between vertices i and j is
# positive, -1 if the edge is positive, 0 if there is no edge, and 10 if
# there is an edge but we have not determined the sign yet.
# triangles is the set of all triangles we know must be the same sign
def signing(G, M, subgraphs, triSign, Triangles):
    alpha = len(G.independent_set())
    #posEigen and negEigen are sets where if a subgraph belongs to posEigen
    #it has alpha(G)+1 positive Eigevalues, and if it belongs to negEigen
    #it has alpha(G)+1 negative eigenvalues
    posEigen = set()
    negEigen = set()
    if debug:
        print "sign of triangles is {}".format(triSign)
    changed = True
    i = 0
    t2 = time.clock()
    while True:
        print "this time around: {}".format(time.clock() - t2)
        changed = False
        for t in Triangles:
            # since we let M[i,j] = 10 if we didn't know the sign of the
            # edge, we know that if we don't know two edges, the sum of
            # the edges will be 19 at the least. Thus, if the sum is less
            # then 19, we know at least two edges. Also, if the sum is
            # >= 8, then we know we only have 1 missing edge and can determine it
            if (M[t[0],t[1]] + M[t[0],t[2]] + M[t[1],t[2]] < 19) and (M[t[0],t[1]] + M[t[0],t[2]] + M[t[1],t[2]] >= 8):
                if debug:
                    i += 1
                    print "step {}:".format(i)
                    print "triangle is {}-{}-{}".format(t[0],t[1],t[2])
                    print "signs are {}-{}: {}, {}-{}: {}, {}-{}: {}".format(t[0],t[1],M[t[0],t[1]],t[0],t[2],M[t[0],t[2]],t[1],t[2],M[t[1],t[2]])
                if M[t[0],t[1]] == 10:
                    if debug:
                        print "new sign is: {}".format(triSign*M[t[0],t[2]]*M[t[1],t[2]])
                    M[t[0],t[1]] = triSign*M[t[0],t[2]]*M[t[1],t[2]]
                    M[t[1],t[0]] = triSign*M[t[0],t[2]]*M[t[1],t[2]]
                if M[t[0],t[2]] == 10:
                    if debug:
                        print "new sign is: {}".format(triSign*M[t[0],t[1]]*M[t[1],t[2]])
                    M[t[0],t[2]] = triSign*M[t[0],t[1]]*M[t[1],t[2]]
                    M[t[2],t[0]] = triSign*M[t[0],t[1]]*M[t[1],t[2]]
                if M[t[1],t[2]] == 10:
                    if debug:
                        print "new sign is: {}".format(triSign*M[t[0],t[1]]*M[t[0],t[2]])
                    M[t[1],t[2]] = triSign*M[t[0],t[1]]*M[t[0],t[2]]
                    M[t[2],t[1]] = triSign*M[t[0],t[1]]*M[t[0],t[2]]
                changed = True
        if changed == False:
            n = G.order()
            if debug or edgesLeft:
                count = 0
                if debug:
                    print "edges that are undetermined:"
                for i in range(n):
                    for j in range(n):
                        if M[i,j] == 10:
                            if debug:
                                print i,j
                            count += 1
                if edgesLeft:
                    print "number of edges undetermined: {}".format(count)
            if debug:
                print M
            break    
        #This loop will once again loop through all triangles, but this time, it will make sure
        #that all the signings that were made in the last loop were valid. (may be unneccessary)
        for t in Triangles:
            if (M[t[0],t[1]] + M[t[0],t[2]] + M[t[1],t[2]] < 8):
                if (M[t[0],t[1]]*M[t[0],t[2]]*M[t[1],t[2]] != triSign):
                    if debug:
                        print "triangle {}-{}-{} is not valid".format(t[0],t[1],t[2])
                        print "signs are {}-{}: {}, {}-{}: {}, {}-{}: {}".format(t[0],t[1],M[t[0],t[1]],t[0],t[2],M[t[0],t[2]],t[1],t[2],    M[t[1],t[2]])
                    return True
        #This loop is used to look through subgraphs and find subgraphs that have fully been signed
        #so we can put them in posEigen or negEigen
        t1 = time.clock()
        for s in subgraphs:
            edgeSigned = True
            for e in s.edge_iterator(labels=False):
                if M[e[0],e[1]] == 10:
                    edgeSigned = False
                    break
            if edgeSigned == False:
                continue
            # if we get to this point, we know that all edges in the subgraph have a
            # sign and so we can determine if it should be in posEigen or negEigen
            c = s.copy(immutable=False)
            for e in c.edge_iterator(labels=False):
                temp1 = e[0]
                temp2 = e[1]
                c.delete_edge(e)
                c.add_edge((temp1,temp2,M[temp1,temp2]))
            if sum(x>0 for x in c.weighted_adjacency_matrix().eigenvalues()) == alpha+1:
                posEigen.add(s)
            else:
                negEigen.add(s)
        print "*#*#*#*#**#*#*#*#*#*#* {}".format(time.clock() - t1)
        if posEigen and negEigen:
            if debug:
                print "Found a contradictory case"
                print M
                subgraph1 = posEigen.pop()
                subgraph2 = negEigen.pop()
                subgraph1c = subgraph1.copy(immutable = False)
                subgraph2c = subgraph2.copy(immutable = False)
                for e in subgraph1c.edge_iterator(labels=False):
                    temp1 = e[0]
                    temp2 = e[1]
                    subgraph1c.delete_edge(e)
                    subgraph1c.add_edge((temp1,temp2,M[temp1,temp2]))
                for e in subgraph2c.edge_iterator(labels=False):
                    temp1 = e[0]
                    temp2 = e[1]
                    subgraph2c.delete_edge(e)
                    subgraph2c.add_edge((temp1,temp2,M[temp1,temp2]))
                print subgraph1c.weighted_adjacency_matrix().eigenvalues()
                print subgraph2c.weighted_adjacency_matrix().eigenvalues()
                graphic1 = subgraph1.plot()
                graphic2 = subgraph2.plot()
                graphic1.save('subgraph1^{}.png'.format(triSign))
                os.system('open subgraph1^{}.png'.format(triSign))
                graphic2.save('subgraph2^{}.png'.format(triSign))
                os.system('open subgraph2^{}.png'.format(triSign))
            return True
    if debug:
        print "did not find a contradiction"
    return False


output_file = open('GraphsBig.txt','a+')
for j in range(24,30):
    i = 0
    print "graphs on {} vertices".format(j)
    output_file.write("Graphs on {} vertices:".format(j))
    output_file.write("\n")
    with open('/Users/zgmdocks/Downloads/VertexTransitiveGraphs/trans{num1:02d}/trans{num2:02d}c.g6'.format(num1=j,num2=j)) as input_file:
        for line in input_file:
            i += 1
            if j == 24 and i < 14732:
                continue
            print "graph {} on {} vertices".format(i,j)
            G = Graph(line)
            if (check(G)):
                print "{} does not have a tight bound".format(line)
                output_file.write(line)



        


